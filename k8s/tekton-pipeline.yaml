apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: rpm-build-pipeline
  labels:
    app: rpm-builder
    component: pipeline
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: pipeline
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: |
    This pipeline builds ASIL-compliant RPM packages for automotive OS from source files or Git repositories.
    It includes safety compliance checks, static analysis, and partition isolation for RHIVOS/AutoSD.
  
  params:
    - name: package-name
      type: string
      description: Name of the RPM package
    - name: package-version  
      type: string
      description: Version of the RPM package
    - name: target-os
      type: string
      description: Target operating system (e.g., rhivos, autosd, fedora-39)
    - name: architecture
      type: string  
      description: Target architecture (e.g., x86_64, aarch64)
    - name: build-id
      type: string
      description: Unique build identifier
    - name: source-type
      type: string
      description: Source type (upload or git)
    - name: git-repository
      type: string
      default: ""
      description: Git repository URL (if source-type is git)
    - name: git-branch
      type: string
      default: "main"
      description: Git branch to checkout
    - name: dependencies
      type: string
      default: ""
      description: Comma-separated list of package dependencies
    - name: build-options
      type: string  
      default: ""
      description: Additional build options
    - name: asil-level
      type: string
      default: "uncertified"
      description: ASIL safety level (uncertified, ASIL-A, ASIL-B, ASIL-C, ASIL-D)
    - name: safety-partition
      type: string
      default: "non-safety"
      description: Target safety partition (safety, non-safety)
    - name: enable-static-analysis
      type: string
      default: "false"
      description: Enable MISRA/static analysis checks
    - name: enable-unit-tests
      type: string
      default: "false"
      description: Enable unit testing and coverage

  workspaces:
    - name: source-workspace
      description: Workspace for source files and build outputs

  tasks:
    - name: prepare-build-environment
      taskRef:
        name: prepare-build-env
      params:
        - name: target-os
          value: $(params.target-os)
        - name: architecture
          value: $(params.architecture)
        - name: build-id
          value: $(params.build-id)
      workspaces:
        - name: source
          workspace: source-workspace

    - name: fetch-sources
      taskRef:
        name: fetch-sources
      runAfter:
        - prepare-build-environment
      params:
        - name: source-type
          value: $(params.source-type)
        - name: git-repository
          value: $(params.git-repository)
        - name: git-branch
          value: $(params.git-branch)
        - name: build-id
          value: $(params.build-id)
      workspaces:
        - name: source
          workspace: source-workspace

    # Note: static-analysis and unit-tests tasks are disabled by default
    # To re-enable them, uncomment the sections below and redeploy
    
    # - name: static-analysis
    #   taskRef:
    #     name: static-analysis
    #   runAfter:
    #     - fetch-sources
    #   params:
    #     - name: package-name
    #       value: $(params.package-name)
    #     - name: asil-level
    #       value: $(params.asil-level)
    #   workspaces:
    #     - name: source
    #       workspace: source-workspace

    # - name: unit-tests
    #   taskRef:
    #     name: unit-tests
    #   runAfter:
    #     - static-analysis
    #   params:
    #     - name: package-name
    #       value: $(params.package-name)
    #     - name: asil-level
    #       value: $(params.asil-level)
    #   workspaces:
    #     - name: source
    #       workspace: source-workspace
    #     - name: output
    #       workspace: output-workspace

    - name: install-dependencies
      taskRef:
        name: install-dependencies
      runAfter:
        - fetch-sources
      params:
        - name: dependencies
          value: $(params.dependencies)
        - name: target-os
          value: $(params.target-os)
      workspaces:
        - name: source
          workspace: source-workspace

    - name: generate-spec-file
      taskRef:
        name: generate-spec-file
      runAfter:
        - install-dependencies
      params:
        - name: package-name
          value: $(params.package-name)
        - name: package-version
          value: $(params.package-version)
        - name: dependencies
          value: $(params.dependencies)
        - name: build-options
          value: $(params.build-options)
        - name: build-id
          value: $(params.build-id)
        - name: target-os
          value: $(params.target-os)
        - name: asil-level
          value: $(params.asil-level)
        - name: safety-partition
          value: $(params.safety-partition)
      workspaces:
        - name: source
          workspace: source-workspace

    - name: build-rpm
      taskRef:
        name: build-rpm-package
      runAfter:
        - generate-spec-file
      params:
        - name: package-name
          value: $(params.package-name)
        - name: package-version
          value: $(params.package-version)
        - name: target-os
          value: $(params.target-os)
        - name: architecture
          value: $(params.architecture)
        - name: build-options
          value: $(params.build-options)
        - name: asil-level
          value: $(params.asil-level)
      workspaces:
        - name: source
          workspace: source-workspace
        - name: output
          workspace: source-workspace

    - name: verify-safety-partition
      taskRef:
        name: verify-safety-partition
      runAfter:
        - build-rpm
      params:
        - name: package-name
          value: $(params.package-name)
        - name: target-os
          value: $(params.target-os)
        - name: asil-level
          value: $(params.asil-level)
        - name: safety-partition
          value: $(params.safety-partition)
      workspaces:
        - name: output
          workspace: source-workspace

    - name: sign-rpm
      taskRef:
        name: sign-rpm
      runAfter:
        - verify-safety-partition
      params:
        - name: package-name
          value: $(params.package-name)
        - name: package-version
          value: $(params.package-version)
        - name: build-id
          value: $(params.build-id)
      workspaces:
        - name: output
          workspace: source-workspace

    - name: publish-artifacts
      taskRef:
        name: publish-rpm-artifacts
      runAfter:
        - sign-rpm
      params:
        - name: package-name
          value: $(params.package-name)
        - name: package-version
          value: $(params.package-version)
        - name: build-id
          value: $(params.build-id)
      workspaces:
        - name: output
          workspace: source-workspace

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: prepare-build-env
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: Prepare the build environment with the appropriate base image
  params:
    - name: target-os
      type: string
    - name: architecture
      type: string
    - name: build-id
      type: string
  workspaces:
    - name: source
  steps:
    - name: setup-environment
      image: $(params.target-os)
      securityContext:
        runAsUser: 0
      script: |
        #!/bin/bash
        set -e
        
        echo "Setting up build environment for $(params.target-os) on $(params.architecture)"
        echo "Build ID: $(params.build-id)"
        
        # Update package manager and install basic build tools
        if command -v dnf > /dev/null; then
          # Skip problematic updates, just install what we need
          dnf install -y --skip-broken rpm-build rpmlint rpmdevtools gcc make git || true
          dnf groupinstall -y "Development Tools" --skip-broken || true
        elif command -v yum > /dev/null; then
          yum install -y --skip-broken rpm-build rpmlint rpmdevtools gcc make git || true
          yum groupinstall -y "Development Tools" --skip-broken || true
        elif command -v zypper > /dev/null; then
          zypper refresh
          zypper install -y rpm-build rpmlint rpmdevtools gcc make git
        elif command -v apt > /dev/null; then
          apt-get update
          apt-get install -y rpm alien build-essential git
        fi
        
        # Create RPM build directory structure
        mkdir -p ~/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
        
        # Set up RPM macros
        echo "%_topdir $(pwd)/rpmbuild" > ~/.rpmmacros
        echo "%_tmppath $(pwd)/rpmbuild/tmp" >> ~/.rpmmacros
        
        echo "Build environment ready"
      workingDir: $(workspaces.source.path)

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: fetch-sources
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: Fetch source files from Git repository or ConfigMaps
  params:
    - name: source-type
      type: string
    - name: git-repository
      type: string
    - name: git-branch
      type: string  
    - name: build-id
      type: string
  workspaces:
    - name: source
  steps:
    - name: fetch-git-sources
      image: alpine/git:latest
      script: |
        #!/bin/sh
        set -e
        
        if [ "$(params.source-type)" = "git" ]; then
          echo "Cloning Git repository: $(params.git-repository)"
          git clone --branch $(params.git-branch) $(params.git-repository) ./source
          cd ./source
          echo "Repository cloned successfully"
          ls -la
        else
          echo "Using uploaded files"
          mkdir -p ./source
        fi
      workingDir: $(workspaces.source.path)
      
    - name: fetch-uploaded-files
      image: registry.redhat.io/ubi8/ubi:latest
      script: |
        #!/bin/bash
        set -e
        
        if [ "$(params.source-type)" = "upload" ]; then
          echo "Extracting uploaded files from ConfigMaps"
          
          # Copy files from mounted ConfigMaps
          if [ -d "/var/configmaps" ]; then
            find /var/configmaps -name "rpm-build-files-$(params.build-id)-*" | while read configmap_dir; do
              echo "Processing configmap: $configmap_dir"
              cp -r "$configmap_dir"/* ./source/ 2>/dev/null || true
            done
          fi
          
          echo "Files extracted to source directory"
          ls -la ./source/
        fi
      workingDir: $(workspaces.source.path)
      volumeMounts:
        - name: configmaps
          mountPath: /var/configmaps
          readOnly: true
  volumes:
    - name: configmaps
      projected:
        sources:
          - configMap:
              name: rpm-build-files-$(params.build-id)-0
              optional: true
          - configMap:
              name: rpm-build-files-$(params.build-id)-1  
              optional: true
          - configMap:
              name: rpm-build-files-$(params.build-id)-2
              optional: true

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: install-dependencies
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin  
spec:
  description: Install package dependencies
  params:
    - name: dependencies
      type: string
    - name: target-os
      type: string
  workspaces:
    - name: source
  steps:
    - name: install-deps
      image: $(params.target-os)
      securityContext:
        runAsUser: 0
      script: |
        #!/bin/bash
        set -e
        
        if [ -n "$(params.dependencies)" ]; then
          echo "Installing dependencies: $(params.dependencies)"
          
          # Convert comma-separated list to array
          IFS=',' read -ra DEPS <<< "$(params.dependencies)"
          
          # Install dependencies based on package manager
          if command -v dnf > /dev/null; then
            dnf install -y "${DEPS[@]}"
          elif command -v yum > /dev/null; then
            yum install -y "${DEPS[@]}"
          elif command -v zypper > /dev/null; then
            zypper install -y "${DEPS[@]}"
          elif command -v apt > /dev/null; then
            apt-get install -y "${DEPS[@]}"
          fi
          
          echo "Dependencies installed successfully"
        else
          echo "No dependencies to install"
        fi
      workingDir: $(workspaces.source.path)

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: generate-spec-file
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: Generate or use provided RPM spec file with automotive safety metadata
  params:
    - name: package-name
      type: string
    - name: package-version
      type: string
    - name: dependencies
      type: string
    - name: build-options
      type: string
    - name: build-id
      type: string
    - name: target-os
      type: string
    - name: asil-level
      type: string
    - name: safety-partition
      type: string
  workspaces:
    - name: source
  steps:
    - name: generate-spec
      image: registry.redhat.io/ubi8/ubi:latest
      script: |
        #!/bin/bash
        set -e
        
        # Ensure RPM build directory structure exists
        mkdir -p ./rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
        
        SPEC_FILE="./rpmbuild/SPECS/$(params.package-name).spec"
        
        # Check if custom spec file exists in ConfigMap
        if [ -f "/var/build-config/spec-file" ]; then
          echo "Using provided custom spec file"
          cp "/var/build-config/spec-file" "$SPEC_FILE"
          
          # Replace placeholders in spec file
          sed -i "s/%{name}/$(params.package-name)/g" "$SPEC_FILE"
          sed -i "s/%{version}/$(params.package-version)/g" "$SPEC_FILE"
          
          if [ -n "$(params.dependencies)" ]; then
            # Replace dependency placeholder
            DEPS=$(echo "$(params.dependencies)" | sed 's/,/ /g')
            sed -i "s/%{dependencies}/$DEPS/g" "$SPEC_FILE"
          fi
        else
          echo "Generating default spec file with automotive safety metadata"
          
          PKG_NAME="$(params.package-name)"
          PKG_VERSION="$(params.package-version)"
          BUILD_OPTS="$(params.build-options)"
          BUILD_DATE="$(date "+%a %b %d %Y")"
          TARGET_OS="$(params.target-os)"
          ASIL_LEVEL="$(params.asil-level)"
          SAFETY_PARTITION="$(params.safety-partition)"
          
          echo "Name: ${PKG_NAME}" > "$SPEC_FILE"
          echo "Version: ${PKG_VERSION}" >> "$SPEC_FILE"
          echo "Release: 1%{?dist}" >> "$SPEC_FILE"
          echo "Summary: ASIL RPM package for ${PKG_NAME}" >> "$SPEC_FILE"
          echo "License: GPL" >> "$SPEC_FILE"
          echo "Group: Applications/Automotive" >> "$SPEC_FILE"
          echo "Source0: ${PKG_NAME}-${PKG_VERSION}.tar.gz" >> "$SPEC_FILE"
          
          # Disable debug package generation (causes issues with simple packages)
          echo "" >> "$SPEC_FILE"
          echo "%global debug_package %{nil}" >> "$SPEC_FILE"
          
          # Automotive Safety Metadata as RPM macros (valid syntax)
          echo "" >> "$SPEC_FILE"
          echo "# Automotive Safety Metadata" >> "$SPEC_FILE"
          echo "%define safety_level ${ASIL_LEVEL}" >> "$SPEC_FILE"
          echo "%define safety_partition ${SAFETY_PARTITION}" >> "$SPEC_FILE"
          echo "%define target_os ${TARGET_OS}" >> "$SPEC_FILE"
          
          # Partition restrictions for uncertified packages
          if [ "${ASIL_LEVEL}" = "uncertified" ]; then
            echo "%define allowed_domains application,user,development" >> "$SPEC_FILE"
            echo "%define prohibited_domains safety-critical,iso26262,asil" >> "$SPEC_FILE"
          fi
          
          # OS-specific metadata
          if [[ "${TARGET_OS}" =~ "rhivos" ]]; then
            echo "%define rhivos_partition partition-${SAFETY_PARTITION}" >> "$SPEC_FILE"
            echo "%define rhivos_zone zone-user" >> "$SPEC_FILE"
          elif [[ "${TARGET_OS}" =~ "autosd" ]]; then
            echo "%define autosd_zone zone-${SAFETY_PARTITION}" >> "$SPEC_FILE"
            echo "%define autosd_container podman-non-safety" >> "$SPEC_FILE"
          fi
          
          if [ -n "$(params.dependencies)" ]; then
            REQUIRES="Requires: $(echo "$(params.dependencies)" | sed 's/,/, /g')"
            echo "${REQUIRES}" >> "$SPEC_FILE"
          fi
          
          echo "" >> "$SPEC_FILE"
          echo "%description" >> "$SPEC_FILE"
          echo "ASIL-compliant RPM package for ${PKG_NAME} built for automotive OS." >> "$SPEC_FILE"
          echo "Safety Level: ${ASIL_LEVEL}" >> "$SPEC_FILE"
          echo "Target Partition: ${SAFETY_PARTITION}" >> "$SPEC_FILE"
          echo "Built using OpenShift RPM Builder with automotive safety compliance." >> "$SPEC_FILE"
          
          # Pre-install safety check
          echo "" >> "$SPEC_FILE"
          echo "%pre" >> "$SPEC_FILE"
          echo "# Safety partition verification" >> "$SPEC_FILE"
          echo "if [ -f /etc/automotive/safety-mode ]; then" >> "$SPEC_FILE"
          echo "  CURRENT_MODE=\$(cat /etc/automotive/safety-mode)" >> "$SPEC_FILE"
          echo "  if [ \"${SAFETY_PARTITION}\" = \"non-safety\" ] && [ \"\$CURRENT_MODE\" = \"safety-critical\" ]; then" >> "$SPEC_FILE"
          echo "    echo \"ERROR: Cannot install non-safety package in safety-critical partition\"" >> "$SPEC_FILE"
          echo "    exit 1" >> "$SPEC_FILE"
          echo "  fi" >> "$SPEC_FILE"
          echo "fi" >> "$SPEC_FILE"
          
          echo "" >> "$SPEC_FILE"
          echo "%prep" >> "$SPEC_FILE"
          echo "%setup -q -c" >> "$SPEC_FILE"
          echo "" >> "$SPEC_FILE"
          echo "%build" >> "$SPEC_FILE"
          echo "# Build with ASIL safety flags" >> "$SPEC_FILE"
          echo "${BUILD_OPTS}" >> "$SPEC_FILE"
          echo "# Check if Makefile exists and build" >> "$SPEC_FILE"
          echo "if [ -f Makefile ]; then" >> "$SPEC_FILE"
          echo "  make %{?_smp_mflags}" >> "$SPEC_FILE"
          echo "else" >> "$SPEC_FILE"
          echo "  echo 'No Makefile found, assuming pre-built or script-based package'" >> "$SPEC_FILE"
          echo "fi" >> "$SPEC_FILE"
          echo "" >> "$SPEC_FILE"
          echo "%install" >> "$SPEC_FILE"
          echo "rm -rf %{buildroot}" >> "$SPEC_FILE"
          echo "mkdir -p %{buildroot}%{_bindir}" >> "$SPEC_FILE"
          echo "# Check if Makefile has install target" >> "$SPEC_FILE"
          echo "if [ -f Makefile ] && grep -q '^install:' Makefile; then" >> "$SPEC_FILE"
          echo "  make install DESTDIR=%{buildroot}" >> "$SPEC_FILE"
          echo "  echo 'Files installed via Makefile:'" >> "$SPEC_FILE"
          echo "  find %{buildroot} -type f" >> "$SPEC_FILE"
          echo "else" >> "$SPEC_FILE"
          echo "  # Install any executables found" >> "$SPEC_FILE"
          echo "  for file in *; do" >> "$SPEC_FILE"
          echo "    if [ -f \"\$file\" ] && [ -x \"\$file\" ]; then" >> "$SPEC_FILE"
          echo "      install -m 755 \"\$file\" %{buildroot}%{_bindir}/" >> "$SPEC_FILE"
          echo "      echo \"Installed: \$file\"" >> "$SPEC_FILE"
          echo "    fi" >> "$SPEC_FILE"
          echo "  done" >> "$SPEC_FILE"
          echo "fi" >> "$SPEC_FILE"
          echo "# Ensure at least one file exists to avoid empty package" >> "$SPEC_FILE"
          echo "if [ ! -f %{buildroot}%{_bindir}/* ] 2>/dev/null; then" >> "$SPEC_FILE"
          echo "  echo 'WARNING: No files installed, creating placeholder'" >> "$SPEC_FILE"
          echo "  echo '#!/bin/sh' > %{buildroot}%{_bindir}/${PKG_NAME}" >> "$SPEC_FILE"
          echo "  echo 'echo \"${PKG_NAME} package installed\"' >> %{buildroot}%{_bindir}/${PKG_NAME}" >> "$SPEC_FILE"
          echo "  chmod 755 %{buildroot}%{_bindir}/${PKG_NAME}" >> "$SPEC_FILE"
          echo "fi" >> "$SPEC_FILE"
          echo "" >> "$SPEC_FILE"
          
          # Post-install SELinux labeling for automotive OS
          echo "%post" >> "$SPEC_FILE"
          if [[ "${TARGET_OS}" =~ "rhivos" ]] || [[ "${TARGET_OS}" =~ "autosd" ]]; then
            echo "# Apply SELinux context for non-safety partition" >> "$SPEC_FILE"
            echo "if command -v semanage >/dev/null 2>&1; then" >> "$SPEC_FILE"
            echo "  semanage fcontext -a -t automotive_non_safety_t \"%{_bindir}/${PKG_NAME}\" 2>/dev/null || true" >> "$SPEC_FILE"
            echo "  restorecon -v %{_bindir}/${PKG_NAME} 2>/dev/null || true" >> "$SPEC_FILE"
            echo "fi" >> "$SPEC_FILE"
            echo "" >> "$SPEC_FILE"
            echo "# Systemd service isolation" >> "$SPEC_FILE"
            echo "if [ -f /etc/systemd/system/${PKG_NAME}.service ]; then" >> "$SPEC_FILE"
            echo "  systemctl daemon-reload" >> "$SPEC_FILE"
            echo "fi" >> "$SPEC_FILE"
          fi
          
          echo "" >> "$SPEC_FILE"
          echo "%clean" >> "$SPEC_FILE"
          echo "rm -rf %{buildroot}" >> "$SPEC_FILE"
          echo "" >> "$SPEC_FILE"
          echo "%files" >> "$SPEC_FILE"
          echo "%defattr(-,root,root,-)" >> "$SPEC_FILE"
          echo "%{_bindir}/*" >> "$SPEC_FILE"
          echo "" >> "$SPEC_FILE"
          echo "%changelog" >> "$SPEC_FILE"
          echo "* ${BUILD_DATE} RPM Builder <rpm-builder@openshift.local> - ${PKG_VERSION}-1" >> "$SPEC_FILE"
          echo "- Initial ASIL package build (${ASIL_LEVEL})" >> "$SPEC_FILE"
          echo "- Target partition: ${SAFETY_PARTITION}" >> "$SPEC_FILE"
        fi
        
        echo "Spec file generated:"
        cat "$SPEC_FILE"
        
        # Validate spec file
        rpmlint "$SPEC_FILE" || echo "Spec file validation completed with warnings"
        
      workingDir: $(workspaces.source.path)
      volumeMounts:
        - name: build-config
          mountPath: /var/build-config
          readOnly: true
  volumes:
    - name: build-config
      configMap:
        name: rpm-build-config-$(params.build-id)

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: build-rpm-package
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: Build the RPM package with ASIL safety compiler flags
  params:
    - name: package-name
      type: string
    - name: package-version
      type: string
    - name: target-os
      type: string
    - name: architecture
      type: string
    - name: build-options
      type: string
    - name: asil-level
      type: string
  workspaces:
    - name: source
    - name: output
  steps:
    - name: build-package
      image: $(params.target-os)
      securityContext:
        runAsUser: 0
      script: |
        #!/bin/bash
        set -e
        
        echo "Building ASIL RPM package: $(params.package-name)"
        echo "Target OS: $(params.target-os)"
        echo "Architecture: $(params.architecture)"
        echo "ASIL Level: $(params.asil-level)"
        
        # Install RPM build tools
        echo "Installing RPM build tools..."
        if command -v dnf > /dev/null; then
          dnf install -y --skip-broken rpm-build rpmdevtools gcc make git || true
        elif command -v yum > /dev/null; then
          yum install -y rpm-build rpmdevtools gcc make git || true
        elif command -v apt-get > /dev/null; then
          apt-get update && apt-get install -y rpm build-essential git || true
        fi
        
        cd $(workspaces.source.path)
        
        # Set ASIL-specific compiler flags
        ASIL_LEVEL="$(params.asil-level)"
        
        # Base safety flags for all ASIL levels
        SAFETY_CFLAGS="-fstack-protector-strong -D_FORTIFY_SOURCE=2 -Werror -Wall -Wextra -Wpedantic"
        SAFETY_CFLAGS="${SAFETY_CFLAGS} -fno-strict-aliasing -fwrapv"
        
        # Additional flags based on ASIL level
        case "${ASIL_LEVEL}" in
          "ASIL-A"|"ASIL-B")
            # Moderate safety requirements
            SAFETY_CFLAGS="${SAFETY_CFLAGS} -O2 -g -fno-omit-frame-pointer"
            ;;
          "ASIL-C"|"ASIL-D")
            # High safety requirements
            SAFETY_CFLAGS="${SAFETY_CFLAGS} -O2 -g3 -fno-omit-frame-pointer"
            SAFETY_CFLAGS="${SAFETY_CFLAGS} -fno-delete-null-pointer-checks -fno-strict-overflow"
            SAFETY_CFLAGS="${SAFETY_CFLAGS} -Wformat -Wformat-security -Wno-unused-parameter"
            ;;
          "uncertified")
            # Standard safe compilation for non-certified packages
            SAFETY_CFLAGS="${SAFETY_CFLAGS} -O2 -g"
            ;;
        esac
        
        echo "Applying ASIL safety compiler flags: ${SAFETY_CFLAGS}"
        export RPM_OPT_FLAGS="${SAFETY_CFLAGS}"
        export CFLAGS="${SAFETY_CFLAGS}"
        export CXXFLAGS="${SAFETY_CFLAGS}"
        
        # Record toolchain information for traceability
        {
          echo "ASIL Build Toolchain Information"
          echo "================================="
          echo "GCC Version: $(gcc --version | head -1)"
          echo "Make Version: $(make --version | head -1)"
          echo "RPM Build Version: $(rpmbuild --version | head -1)"
          echo "Compiler Flags: ${SAFETY_CFLAGS}"
          echo "Build Date: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "ASIL Level: ${ASIL_LEVEL}"
        } > ./rpmbuild/BUILD/toolchain-info.txt
        
        # Copy sources to RPM SOURCES directory
        if [ -d "./source" ]; then
          tar czf "./rpmbuild/SOURCES/$(params.package-name)-$(params.package-version).tar.gz" -C ./source .
        fi
        
        # Build the RPM package with safety flags
        rpmbuild -ba "./rpmbuild/SPECS/$(params.package-name).spec" \
          --define "_topdir $(pwd)/rpmbuild" \
          --define "optflags ${SAFETY_CFLAGS}" \
          --target $(params.architecture)
        
        echo "RPM build completed successfully with ASIL compliance"
        
        # Copy built RPMs to output workspace
        mkdir -p $(workspaces.output.path)/rpms
        find ./rpmbuild/RPMS -name "*.rpm" -exec cp {} $(workspaces.output.path)/rpms/ \;
        find ./rpmbuild/SRPMS -name "*.rpm" -exec cp {} $(workspaces.output.path)/rpms/ \;
        
        # Copy toolchain info for traceability
        cp ./rpmbuild/BUILD/toolchain-info.txt $(workspaces.output.path)/ 2>/dev/null || true
        
        echo "Built RPM packages:"
        ls -la $(workspaces.output.path)/rpms/
        
        # Generate build report with ASIL information
        {
          echo "ASIL RPM Build Report"
          echo "====================="
          echo "Package Name: $(params.package-name)"
          echo "Package Version: $(params.package-version)"
          echo "Target OS: $(params.target-os)"
          echo "Architecture: $(params.architecture)"
          echo "ASIL Level: ${ASIL_LEVEL}"
          echo "Build Time: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Build Options: $(params.build-options)"
          echo "Safety Compiler Flags: ${SAFETY_CFLAGS}"
          echo ""
          echo "Toolchain Information:"
          cat ./rpmbuild/BUILD/toolchain-info.txt 2>/dev/null || echo "N/A"
          echo ""
          echo "Built Packages:"
          ls -la $(workspaces.output.path)/rpms/
          echo ""
          echo "Package Checksums:"
          cd $(workspaces.output.path)/rpms/
          sha256sum *.rpm || true
        } > $(workspaces.output.path)/build-report.txt

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: publish-rpm-artifacts
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: Publish RPM artifacts to registry or storage
  params:
    - name: package-name
      type: string
    - name: package-version
      type: string
    - name: build-id
      type: string
  workspaces:
    - name: output
  steps:
    - name: publish-artifacts
      image: registry.redhat.io/ubi8/ubi:latest
      script: |
        #!/bin/bash
        set -e
        
        echo "Publishing RPM artifacts for $(params.package-name)-$(params.package-version)"
        
        cd $(workspaces.output.path)
        
        # Create a manifest of built artifacts
        TIMESTAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        PKG_NAME="$(params.package-name)"
        PKG_VERSION="$(params.package-version)"
        BUILD_ID="$(params.build-id)"
        
        echo "{" > manifest.json
        echo "  \"package\": \"${PKG_NAME}\"," >> manifest.json
        echo "  \"version\": \"${PKG_VERSION}\"," >> manifest.json
        echo "  \"buildId\": \"${BUILD_ID}\"," >> manifest.json
        echo "  \"timestamp\": \"${TIMESTAMP}\"," >> manifest.json
        echo "  \"artifacts\": [" >> manifest.json
        
        # List all RPM files
        first=true
        for rpm in rpms/*.rpm; do
          if [ "$first" = true ]; then
            first=false
          else
            echo "," >> manifest.json
          fi
          
          # Get file size (BSD stat or GNU stat)
          if stat -f%z "$rpm" 2>/dev/null; then
            FILE_SIZE=$(stat -f%z "$rpm" 2>/dev/null)
          else
            FILE_SIZE=$(stat -c%s "$rpm" 2>/dev/null)
          fi
          
          echo "    {" >> manifest.json
          echo "      \"name\": \"$(basename "$rpm")\"," >> manifest.json
          echo "      \"size\": ${FILE_SIZE}," >> manifest.json
          echo "      \"checksum\": \"$(sha256sum "$rpm" | cut -d' ' -f1)\"" >> manifest.json
          echo "    }" >> manifest.json
        done
        
        echo "  ]" >> manifest.json
        echo "}" >> manifest.json
        
        echo "Build artifacts published successfully"
        echo "Manifest:"
        cat manifest.json
        
        # TODO: Upload to actual artifact repository
        # This could be integrated with a container registry, S3, or other storage
        echo "Artifacts ready for download"

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: static-analysis
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: Perform static analysis and MISRA compliance checking
  params:
    - name: package-name
      type: string
    - name: asil-level
      type: string
  workspaces:
    - name: source
  steps:
    - name: static-analysis
      image: registry.redhat.io/ubi8/ubi:latest
      securityContext:
        runAsUser: 0
      script: |
        #!/bin/bash
        set -e
        
        echo "Running static analysis for $(params.package-name)"
        echo "ASIL Level: $(params.asil-level)"
        
        cd $(workspaces.source.path)/source
        
        # Install static analysis tools
        dnf install -y cppcheck clang clang-tools-extra || true
        
        # Run cppcheck for basic static analysis
        echo "Running cppcheck..."
        find . -name "*.c" -o -name "*.cpp" -o -name "*.h" -o -name "*.hpp" | \
          xargs cppcheck --enable=all --error-exitcode=0 \
          --suppress=missingIncludeSystem \
          --xml --xml-version=2 2> cppcheck-report.xml || true
        
        # Run clang-tidy for additional checks
        echo "Running clang-tidy..."
        find . -name "*.c" -o -name "*.cpp" | \
          xargs clang-tidy --checks='*' --format-style=file || true
        
        # MISRA compliance checking (placeholder - requires commercial tools)
        echo "MISRA Compliance Check"
        echo "======================"
        echo "Note: Full MISRA C compliance requires commercial tools like:"
        echo "  - LDRA Testbed"
        echo "  - Polyspace"
        echo "  - PC-lint Plus"
        echo ""
        echo "This is a placeholder for MISRA checking."
        echo "For production use, integrate your organization's MISRA checker here."
        
        # Check for common automotive safety violations
        echo "Checking for common safety violations..."
        
        # Check for dangerous functions
        DANGEROUS_FUNCS="gets strcpy sprintf vsprintf"
        for func in $DANGEROUS_FUNCS; do
          if grep -r "\b${func}\b" . 2>/dev/null; then
            echo "WARNING: Found usage of dangerous function: ${func}"
            echo "  These functions are prohibited in automotive safety-critical code"
          fi
        done
        
        # Check for malloc/free in safety code (ASIL-C/D should use static allocation)
        if [ "$(params.asil-level)" = "ASIL-C" ] || [ "$(params.asil-level)" = "ASIL-D" ]; then
          if grep -r "\bmalloc\b\|\\bfree\b" . 2>/dev/null; then
            echo "WARNING: Dynamic memory allocation found in ASIL-C/D code"
            echo "  Consider using static memory allocation for safety-critical code"
          fi
        fi
        
        echo "Static analysis completed"
        echo "Review cppcheck-report.xml for detailed findings"
      workingDir: $(workspaces.source.path)

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: unit-tests
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: Run unit tests and generate coverage reports
  params:
    - name: package-name
      type: string
    - name: asil-level
      type: string
  workspaces:
    - name: source
    - name: output
  steps:
    - name: run-tests
      image: registry.redhat.io/ubi8/ubi:latest
      securityContext:
        runAsUser: 0
      script: |
        #!/bin/bash
        set -e
        
        echo "Running unit tests for $(params.package-name)"
        echo "ASIL Level: $(params.asil-level)"
        
        cd $(workspaces.source.path)/source
        
        # Install test tools
        dnf install -y gcc make lcov gcovr || true
        
        # Define coverage thresholds based on ASIL level
        ASIL_LEVEL="$(params.asil-level)"
        case "${ASIL_LEVEL}" in
          "ASIL-D")
            REQUIRED_COVERAGE=100
            ;;
          "ASIL-C")
            REQUIRED_COVERAGE=95
            ;;
          "ASIL-B")
            REQUIRED_COVERAGE=90
            ;;
          "ASIL-A")
            REQUIRED_COVERAGE=80
            ;;
          "uncertified")
            REQUIRED_COVERAGE=70
            ;;
        esac
        
        echo "Required code coverage for ${ASIL_LEVEL}: ${REQUIRED_COVERAGE}%"
        
        # Look for test executables or test scripts
        if [ -f "Makefile" ]; then
          if grep -q "test:" Makefile; then
            echo "Running make test..."
            make test || echo "Tests completed with failures"
          else
            echo "No test target found in Makefile"
          fi
        fi
        
        # Look for common test directories
        for test_dir in tests test unit_tests; do
          if [ -d "$test_dir" ]; then
            echo "Found test directory: $test_dir"
            cd "$test_dir"
            
            # Try to run tests
            if [ -f "run_tests.sh" ]; then
              bash run_tests.sh || echo "Test execution completed"
            fi
            
            cd ..
          fi
        done
        
        # Generate coverage report if gcov data exists
        if find . -name "*.gcda" | grep -q .; then
          echo "Generating coverage report..."
          gcovr --xml --xml-pretty --output coverage.xml .
          
          # Extract coverage percentage
          COVERAGE=$(gcovr --print-summary | grep "lines:" | awk '{print $2}' | tr -d '%')
          
          echo "Code Coverage: ${COVERAGE}%"
          echo "Required Coverage: ${REQUIRED_COVERAGE}%"
          
          # Save coverage report
          mkdir -p $(workspaces.output.path)/reports
          cp coverage.xml $(workspaces.output.path)/reports/ 2>/dev/null || true
          
          # Check if coverage meets requirements
          if (( $(echo "$COVERAGE < $REQUIRED_COVERAGE" | bc -l) )); then
            echo "WARNING: Code coverage ${COVERAGE}% is below required ${REQUIRED_COVERAGE}%"
            echo "  This may not meet ASIL ${ASIL_LEVEL} requirements"
          else
            echo "SUCCESS: Code coverage meets ${ASIL_LEVEL} requirements"
          fi
        else
          echo "No coverage data found. Ensure tests are built with --coverage flag"
        fi
        
        echo "Unit testing completed"
      workingDir: $(workspaces.source.path)

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: verify-safety-partition
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: Verify RPM compliance with safety partition requirements for RHIVOS/AutoSD
  params:
    - name: package-name
      type: string
    - name: target-os
      type: string
    - name: asil-level
      type: string
    - name: safety-partition
      type: string
  workspaces:
    - name: output
  steps:
    - name: verify-partition
      image: registry.redhat.io/ubi8/ubi:latest
      securityContext:
        runAsUser: 0
      script: |
        #!/bin/bash
        set -e
        
        echo "Verifying safety partition compliance"
        echo "======================================"
        echo "Package: $(params.package-name)"
        echo "Target OS: $(params.target-os)"
        echo "ASIL Level: $(params.asil-level)"
        echo "Safety Partition: $(params.safety-partition)"
        
        # Install RPM tools
        dnf install -y --skip-broken rpm rpm-build || true
        
        # Find the spec file for metadata verification
        SPEC_FILE=$(find $(workspaces.output.path) -name "$(params.package-name).spec" | head -1)
        
        if [ -n "$SPEC_FILE" ]; then
          echo ""
          echo "Verifying safety metadata from spec file:"
          grep -E "%(define|global) (safety_|rhivos_|autosd_)" "$SPEC_FILE" || echo "⚠ No safety metadata macros found"
        fi
        
        cd $(workspaces.output.path)/rpms
        
        # Find the built RPM
        RPM_FILE=$(find . -name "$(params.package-name)-*.rpm" -not -name "*.src.rpm" | head -1)
        
        if [ -z "$RPM_FILE" ]; then
          echo "ERROR: RPM file not found"
          exit 1
        fi
        
        echo "Verifying RPM: $RPM_FILE"
        
        # Extract RPM metadata
        echo ""
        echo "RPM Metadata:"
        rpm -qp --info "$RPM_FILE"
        
        # Verify safety metadata is present
        echo ""
        echo "Safety Metadata Verification:"
        
        # Verify expected safety level matches
        EXPECTED_ASIL="$(params.asil-level)"
        EXPECTED_PARTITION="$(params.safety-partition)"
        
        echo "✓ Expected ASIL Level: $EXPECTED_ASIL"
        echo "✓ Expected Safety Partition: $EXPECTED_PARTITION"
        
        # Check for RHIVOS/AutoSD specific metadata in spec file
        TARGET_OS="$(params.target-os)"
        if [[ "$TARGET_OS" =~ "rhivos" ]] && [ -n "$SPEC_FILE" ]; then
          echo ""
          echo "RHIVOS-specific checks:"
          grep -E "%define rhivos_" "$SPEC_FILE" || echo "⚠ RHIVOS metadata not found in spec"
        elif [[ "$TARGET_OS" =~ "autosd" ]] && [ -n "$SPEC_FILE" ]; then
          echo ""
          echo "AutoSD-specific checks:"
          grep -E "%define autosd_" "$SPEC_FILE" || echo "⚠ AutoSD metadata not found in spec"
        fi
        
        # Verify uncertified packages are marked for non-safety partitions
        ASIL_LEVEL="$(params.asil-level)"
        if [ "$ASIL_LEVEL" = "uncertified" ] && [ -n "$SPEC_FILE" ]; then
          echo ""
          echo "Partition Restrictions for Uncertified Package:"
          grep -E "%define (allowed_domains|prohibited_domains)" "$SPEC_FILE" || echo "⚠ Domain restrictions not found in spec"
          
          if grep -q "%define prohibited_domains.*safety-critical" "$SPEC_FILE" 2>/dev/null; then
            echo "✓ Package correctly prohibited from safety-critical partitions"
          else
            echo "⚠ WARNING: Package may not be properly restricted from safety partitions"
          fi
        fi
        
        # Check for pre-install scripts that verify partition
        echo ""
        echo "Installation Guard Scripts:"
        rpm -qp --scripts "$RPM_FILE" | grep -A 10 "preinstall scriptlet" || echo "No pre-install scripts found"
        
        # Generate verification report
        {
          echo "Safety Partition Verification Report"
          echo "====================================="
          echo "Package: $(params.package-name)"
          echo "RPM File: $RPM_FILE"
          echo "Target OS: $TARGET_OS"
          echo "ASIL Level: $EXPECTED_ASIL"
          echo "Target Partition: $EXPECTED_PARTITION"
          echo "Verification Date: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo ""
          echo "Metadata Check:"
          echo "  Safety Level: $EXPECTED_ASIL"
          echo "  Safety Partition: $EXPECTED_PARTITION"
          echo ""
          echo "RPM Info:"
          rpm -qp --info "$RPM_FILE"
        } > $(workspaces.output.path)/partition-verification-report.txt
        
        echo ""
        echo "✓ Safety partition verification completed"
        echo "Report saved to: partition-verification-report.txt"
      workingDir: $(workspaces.output.path)

---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: sign-rpm
  labels:
    app: rpm-builder
    component: task
    app.kubernetes.io/name: rpm-builder
    app.kubernetes.io/component: task
    app.kubernetes.io/part-of: rpm-builder-plugin
spec:
  description: Sign RPM packages for authenticity and integrity
  params:
    - name: package-name
      type: string
    - name: package-version
      type: string
    - name: build-id
      type: string
  workspaces:
    - name: output
  steps:
    - name: sign-packages
      image: registry.redhat.io/ubi8/ubi:latest
      securityContext:
        runAsUser: 0
      script: |
        #!/bin/bash
        set -e
        
        echo "Signing RPM packages for $(params.package-name)-$(params.package-version)"
        
        cd $(workspaces.output.path)/rpms
        
        # Install RPM signing tools
        dnf install -y rpm-sign gnupg2 || true
        
        # TODO: In production, use proper GPG key management
        # This is a placeholder that demonstrates the signing process
        # Real implementation should use:
        #  - Hardware Security Module (HSM) for key storage
        #  - Proper key management procedures
        #  - Certificate authority integration
        
        echo "Package Signing Process"
        echo "======================="
        echo "Note: This is a placeholder for RPM signing"
        echo ""
        echo "In production, implement:"
        echo "  1. Load GPG private key from secure storage (HSM/Vault)"
        echo "  2. Sign all RPM packages with: rpm --addsign *.rpm"
        echo "  3. Verify signatures with: rpm --checksig *.rpm"
        echo "  4. Record signing event in audit log"
        echo ""
        
        # Generate checksums for integrity verification
        echo "Generating integrity checksums..."
        sha256sum *.rpm > SHA256SUMS
        
        echo "Package checksums:"
        cat SHA256SUMS
        
        # Create signing manifest
        {
          echo "RPM Signing Manifest"
          echo "===================="
          echo "Package: $(params.package-name)"
          echo "Version: $(params.package-version)"
          echo "Build ID: $(params.build-id)"
          echo "Signing Date: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo ""
          echo "Packages:"
          ls -la *.rpm
          echo ""
          echo "Checksums:"
          cat SHA256SUMS
        } > $(workspaces.output.path)/signing-manifest.txt
        
        echo ""
        echo "✓ Package integrity verification completed"
        echo "Note: Implement GPG signing for production use"
      workingDir: $(workspaces.output.path)
